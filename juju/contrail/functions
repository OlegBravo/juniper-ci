#!/bin/bash -e

function check_containers() {
  local base_url='https://s3-us-west-2.amazonaws.com/contrailpkgs'
  mkdir -p "$HOME/docker"
  packages="contrail_debs-${BUILD}-${VERSION}.tgz"
  local uver=""
  if [[ "$SERIES" == "trusty" ]] ; then
    local uver="14.04"
  elif [[ "$SERIES" == "xenial" ]] ; then
    local uver="16.04"
  fi
  image_controller="contrail-controller-ubuntu${uver}-4.0.0.0-${BUILD}.tar.gz"
  image_analytics="contrail-analytics-ubuntu${uver}-4.0.0.0-${BUILD}.tar.gz"
  image_analyticsdb="contrail-analyticsdb-ubuntu${uver}-4.0.0.0-${BUILD}.tar.gz"
  for ff in "$packages" "$image_controller"  "$image_analytics" "$image_analyticsdb" ; do
    if [ -f "$HOME/docker/$ff" ] ; then
      local flsize=$(stat -c%s "$HOME/docker/$ff")
      local frsize=$(curl --head -s ${base_url}/$ff | awk '/Content-Length/{print $2}' | tr -d '\r')
      local fltime=$(stat -c%Y "$HOME/docker/$ff")
      local frtime_full=`curl --head -s ${base_url}/$ff | awk '/Last-Modified/{print substr($0, index($0,$3))}' | tr -d '\r'`
      local frtime=`date --date="$frtime_full" +%s`
      if [[ "$flsize" != "$frsize" ]] ; then
        echo "INFO: Local file size ($flsize) is not equal to remote ($frsize). File is to be removed for re-download."
      elif [[ "$fltime" != "$frtime" ]] ; then
        echo "INFO: Local file time ($(stat -c%y "$HOME/docker/$ff")) is not equal to remote ($frtime_full). File is to be removed re-download."
      else
        continue
      fi
    fi

    rm -f "$HOME/docker/$ff"
    echo "INFO: download ${base_url}/$ff to $HOME/docker/$ff"
    if ! wget -nv "${base_url}/$ff" -O "$HOME/docker/$ff" ; then
      rm -f "$HOME/docker/$ff"
      echo "ERROR: Can't download ${base_url}/$ff to $HOME/docker/$ff"
      exit 1
    fi
  done
}

function prepare_repo() {
  echo "INFO: Prepare apt-repo"
  mrepo=$(create_machine mem=4G cores=1 root-disk=40G)
  echo "INFO: Machine created: $mrepo"
  if ! wait_for_machines $mrepo ; then
    return 1
  fi
  juju-deploy cs:$SERIES/ubuntu --to $mrepo
  juju-scp "$HOME/docker/$packages" "$mrepo:contrail_debs.tgz"
  juju-scp "$my_dir/create-aptrepo.sh" $mrepo:create-aptrepo.sh
  open_port $mrepo 80
  juju-ssh $mrepo ./create-aptrepo.sh $SERIES
  echo "INFO: apt-repo is ready"
}

function detect_subnet() {
  local ids=(`aws ec2 describe-subnets --filters Name=availability-zone,Values=$AZ Name=vpc-id,Values=$vpc_id Name=defaultForAz,Values=false --query 'Subnets[*].SubnetId' --output text`)
  if [[ ${#ids[@]} == 0 ]] ; then
    # TODO: add CIDR detection from VPC. add CIDR choosing if it present in another AZ.
    aws ec2 create-subnet --vpc-id $vpc_id --cidr-block 172.31.100.0/24 --availability-zone $AZ
    local ids=(`aws ec2 describe-subnets --filters Name=availability-zone,Values=$AZ Name=vpc-id,Values=$vpc_id Name=defaultForAz,Values=false --query 'Subnets[*].SubnetId' --output text`)
    subnet_id=${ids[0]}
  else
    subnet_id=${ids[0]}
  fi
  subnet_cidr=`aws ec2 describe-subnets --subnet-id $subnet_id --query 'Subnets[0].CidrBlock' --output text`
  echo "INFO: additional subnet_id is $subnet_id and CIDR is $subnet_cidr"
}

function add_interface() {
  local mch=$1

  if [[ -z "$subnet_id" ]] ; then
    echo "ERROR: additional subnet is not defined"
    return 1
  fi

  iid=`get-machine-id-by-number $mch`
  if [[ -z "$iid" ]] ; then
    echo "ERROR: Can't get instance_id for machine $mch"
    return 1
  fi

  eni_id=`aws ec2 create-network-interface --subnet-id $subnet_id --query 'NetworkInterface.NetworkInterfaceId' --output text`
  eni_attach_id=`aws ec2 attach-network-interface --network-interface-id $eni_id --instance-id $iid --device-index 1 --query 'AttachmentId' --output text`
  aws ec2 modify-network-interface-attribute --network-interface-id $eni_id --attachment AttachmentId=$eni_attach_id,DeleteOnTermination=true
  sleep 5
  echo "INFO: additional interface $eni_id attached to instance $mch:$iid - $eni_attach_id"

  nif=`juju-ssh $mch "sudo lshw" 2>/dev/null | grep -A 10 'network.*DISABLED' | awk '/logical name/{print $3}' | head -1 | tr -d '\r'`
  juju-ssh $mch "sudo bash -c 'echo \"auto $nif\" > /etc/network/interfaces.d/$nif.cfg && echo \"iface $nif inet dhcp\" >> /etc/network/interfaces.d/$nif.cfg && ifup $nif'" 2>/dev/null
  echo "INFO: interface $nif added"
  sleep 5
  juju-ssh $mch ifconfig 2>/dev/null | grep -A 1 "^[a-z].*" | grep -v "\-\-"
}

function detect_machines() {
  m1=`get_machine_index_by_service openstack-dashboard`
  m2=`get_machine_index_by_service glance`
  m3=`get_machine_index_by_service keystone`
  m4=`get_machine_index_by_service nova-cloud-controller`
  m5=`get_machine_index_by_service neutron-api`
  m6=`get_machine_index_by_service contrail-controller`
}

function hack_openstack() {
  if [[ "$jver" == 2 ]] ; then
    # Juju 2.0 registers services with private ips (using new modern tool 'network-get public')
    echo "INFO: HACK: Reconfigure public endpoints for OpenStack $(date)"

    local mchs=("$m2" "$m3" "$m4" "$m5")
    local mch_srvs=('glance' 'keystone' 'nova-cloud-controller' 'neutron-api')
    local mch_sets=('0' '0' '0' '0')
    for j in {1..30} ; do
      echo "INFO: attempt $j"
      for i in {0..3} ; do
        if [[ ${mch_sets[$i]} != '0' ]] ; then
          continue;
        fi
        local addr_count=`juju machines --format json | python -c "import sys; import json; sys.stdout.write(str(len(json.load(sys.stdin)['machines'].get('${mchs[$i]}', {}).get('ip-addresses', []))))"`
        if [[ $addr_count != '0' ]] ; then
          local ip=`get-machine-ip-by-number ${mchs[$i]}`
          echo "INFO: Update hostnames of ${mch_srvs[$i]} with IP=$ip"
          juju-set ${mch_srvs[$i]} os-public-hostname=$ip os-admin-hostname=$ip os-internal-hostname=$ip
          mch_sets[$i]='1'
        fi
      done
      if ! echo ${mch_sets[@]} | grep -q '0' ; then
        break
      fi
      sleep 2
    done
  fi

  # open admin port of keystone - to be able to create projects
  open_port $m3 35357
  # open port for vnc console
  open_port $m4 6080
}

function post_deploy() {
  echo "INFO: Waiting for services start: $(date)"

  if ! wait_absence_status_for_services "executing|blocked|waiting" 39 ; then
    echo "ERROR: Waiting for services end: $(date)"
    return 1
  fi
  echo "INFO: Waiting for services end: $(date)"

  # check for errors
  if juju-status | grep "current" | grep error ; then
    echo "ERROR: Some services went to error state"
    juju-ssh 0 sudo grep Error /var/log/juju/all-machines.log 2>/dev/null
    return 1
  fi

  juju-status-tabular
}

function apply_ssl() {
  ssl_dir="$WORKSPACE/ssl"
  rm -rf "$ssl_dir"
  mkdir -p "$ssl_dir"

cat >"$ssl_dir/v3.ext" <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
EOF

  create_root_ca

  apply_ssl_os
  apply_ssl_contrail
}

function apply_ssl_os() {
  if [[ "$USE_SSL_OS" != "true" ]] ; then
    return
  fi

  # due to bug https://bugs.launchpad.net/charm-neutron-api/+bug/1690912 we'll set only keystone SSL
  #local mchs=("$m1" "$m2" "$m3" "$m4" "$m5")
  #local mch_srvs=('openstack-dashboard' 'glance' 'keystone' 'nova-cloud-controller' 'neutron-api')
  local mchs=("$m3")
  local mch_srvs=('keystone')
  for i in ${!mchs[@]} ; do
    apply_ssl_config ${mchs[$i]} ${mch_srvs[$i]}
  done
  # instead of adding certificates to other services we have to add rootCA to all other machines
  # (setting ssl_ca for each module doesn't do something useful and keystone doesn't do it byself)
  for mch in "$m1" "$m2" "$m4" "$m5" ; do
    echo "INFO: adding rootCA to machine $mch"
    juju-scp "$ssl_dir/rootCA.crt" "${mch}:rootCA.crt"
    juju-ssh $mch sudo mkdir -p /usr/local/share/ca-certificates/openstack
    juju-ssh $mch sudo cp rootCA.crt /usr/local/share/ca-certificates/openstack/
    juju-ssh $mch sudo update-ca-certificates
  done

  juju-set keystone "use-https=True"
}

function create_root_ca() {
  openssl genrsa -out "$ssl_dir/rootCA.key" 2048 &>/dev/null
  openssl req -x509 -new -key "$ssl_dir/rootCA.key" -days 365 -out "$ssl_dir/rootCA.crt" -subj "/C=US/ST=CA/L=SV/O=Juniper/CN=RootCA" &>/dev/null
  cat "$ssl_dir/rootCA.crt" | base64 > "$ssl_dir/rootCA.crt.b64"
}

function apply_ssl_config() {
  local mch=$1
  local srv=$2

  local addr=`get-machine-ip-by-number $mch`
  apply_ssl_config_by_addr $mch $srv $addr
}

function apply_ssl_config_by_addr() {
  local mch=$1
  local srv=$2
  local addr=$3

  echo "INFO: creating certificate for address: $addr (machine $mch / service $srv)"
  local cfname="cert_m${mch}_${addr}"
  openssl genrsa -out "$ssl_dir/$cfname.key" 2048
  openssl req -new -key "$ssl_dir/$cfname.key" -out "$ssl_dir/$cfname.csr" -subj "/C=US/ST=CA/L=Sunnyvale/O=Juniper/CN=$addr"
  openssl x509 -req -in "$ssl_dir/$cfname.csr" -extfile "$ssl_dir/v3.ext" -CA "$ssl_dir/rootCA.crt" -CAkey "$ssl_dir/rootCA.key" -CAcreateserial -out "$ssl_dir/$cfname.crt" -days 365
  cat "$ssl_dir/$cfname.crt" | base64 > "$ssl_dir/$cfname.crt.b64"
  cat "$ssl_dir/$cfname.key" | base64 > "$ssl_dir/$cfname.key.b64"

  local ssl_config="$ssl_dir/ssl_config_m$mch.yaml"
  echo "$srv:" > "$ssl_config"
  echo "  ssl_ca: |" >> "$ssl_config"
  cat "$ssl_dir/rootCA.crt.b64" | awk '{printf("    %s\n", $0)}' >> "$ssl_config"
  echo "  ssl_cert: |" >> "$ssl_config"
  cat "$ssl_dir/$cfname.crt.b64" | awk '{printf("    %s\n", $0)}' >> "$ssl_config"
  echo "  ssl_key: |" >> "$ssl_config"
  cat "$ssl_dir/$cfname.key.b64" | awk '{printf("    %s\n", $0)}' >> "$ssl_config"

  juju-set $srv --file "$ssl_config"
}

function apply_ssl_contrail() {
  if [[ "$USE_SSL_CONTRAIL" != "true" ]] ; then
    return
  fi

  mch=$m6
  local addr=`get-machine-ip-by-number $mch`
  addr=`juju machines --format json | python -c "import sys; import json; [sys.stdout.write(addr + '\n') for addr in json.load(sys.stdin)['machines'].get('$mch', {}).get('ip-addresses', [])]" | grep -v $addr`
  apply_ssl_config_by_addr $mch "contrail-controller" $addr
}
